{"posts":[{"title":"2019-2020 跨年博客","content":"写跨年博客的想法其实很早就有了，但每到真正下笔时却总是半途而废。再忙也好、再晚也好，我今天说什么都要把这篇博客写完推到网上。 人们常说人生有三个转折点：出生、高考、婚嫁。如果说 2017-2018 让我对人生重新做了选择，那么 2019 年对我来说，无疑是检验这次选择的关键一年。 2019 生活 在杭电的生活一定能算得上是丰富而多元的。我看了不下 20 场的文艺演出和学术讲座，闲时有也常去周边的城市逛逛：从南京到上海，再到苏州和武汉……眼界着实开阔了不少，看到了平静村落下的朴实善良，也看到繁华都市里的「熙熙攘攘」。 苏州街头的小桥流水 学校离西湖景区只有 40 分钟地铁，一年下来我也只走过 1/10 吧，嗯毕业前一定会打卡每个景点的！ 9 教随手拍 第一次去看演唱会，那种和 idol 近在咫尺的感觉真的很棒！陈绮贞、逃跑计划、万青、林宥嘉、岸部真明（我和岸部大叔面对面！！） 岸部真明 x 下山亮平 2019 杭州演奏会 我的舍友都超级 nice，好多小细节上能体现出他们的修养（不像我这种憨憨直男哈哈哈），每到学期末和重要日子还会很仪式性地出去搓一顿。（也挺好玩的哈哈哈，过了快半年了才互相发现原来 5 个里有 3 个都是复读生 每一次回家总能感觉到家人在慢慢变老。外公外婆这两年身体每况愈下，虽然生活尚能自理，但总感觉他们已被阿兹海默症的洪水冲毁了常识和心智，也因此遗失了感情。 我很希望我能做些什么，真的，不想再看到我妈哭了。 社团 参加了杭电助手和红色家园两个重技术型的社团（也不出所料地成为了两家之间的双面间谍 溜了溜了），认识了很多很多这方面的牛人和志同道合的朋友，甚至还借社团的名义帮学校做了好多事情（学院的官网、微信新生报到、重构各类外包系统等等），这些宝贵的人脉和经历，我想只有助手和红家能带给我，只有杭电能带给我。 原本只想做一个闷头实现功能写代码的人，谁知阴差阳错还是当上了前端的部长。从最初的线上宣传，一个一个和我「未来」的部员们聊过去，到组织笔试、二面、三面，再到每一周组织例会……所幸，这一年里我的表现（和魅力）还算说得过去，大家都很认真很可爱，不仅没有像我那时的前端部一样没到几个月便隐居山林不再出现，还很积极地完成我给的各种作业和社团任务，有的甚至还和我在办公室里熬夜复习，这对我来说已经是莫大的肯定了。 助手的🐱（现在已经放生了，想它） 社团的开发工作和部门上的这些事情大概占据了我超过一半的空余时间，真的很累很累，但不得不说，这段日子里我真的，真的超级开心。 开会偷拍我的部员们 助手破冰，跳失恋阵线联盟 竞赛和创业？ 因为总想着要出国，大大小小的比赛也报了不下 10 场。挑战杯，互联网+、服务外包、大创新苗……每一次打比赛都让人觉得特别不舒服，不仅仅是要在规定时间内交上足够满意的结果所带来的一阵阵焦虑，更有因为团队管理上的缺乏经验而自卑，和生怕辜负队友、老师努力和期待的强烈不安。 原本只是无心插柳，可歪打正着地遇上了学校创业类的金牌指导老师老吴，他不仅仅是在比赛技巧上，更从我的发展方向，人生角度上给了我很多经验和思考。 第一次认识老吴时总觉得他看起来像个挺不靠谱的老师，比如什么忘记了报名的时间、校赛那天没注意我们讲的什么，但他一到真正的关键时刻却只能让你从内心发出由衷的佩服，你也不知道这小小的身躯里到底装了多少的知识和才华。 参加第五届省互联网+，输的超惨哈哈 他还总能给我带来许多感动（有一次甚至还和老婆孩子打电话说今晚辅导学生不回去了）。我总记得互联网+比赛失利那天，回想起队友为了这次比赛推掉了原本安排好的行程，努力了这么久最后却落得小组倒数的成绩，我心有不甘，更多的是愧疚和自责。要知道悲伤同样可以被传染，我又怎敢向队友再分享这种负面的情绪呢。我发短信给老吴，为我的状态不佳向他道歉时——我第一次听到，听到一个以老师身份的人，能耐下心来接受我所有的不安和焦虑，还对我这样保证。 「我今后一定帮你把企业做大做强。」 我实在没有勇气和他说创办公司只为了打比赛这回事。 可我每每想起那段时光，眼里总噙泪水。 感情 很遗憾，9102 年我还是没脱单。不过今年是和往常不同，收到过不明所以的短信、也从微博上无意翻到别人对我的评价，甚至让我还差点动了内销的念头…… 这一年里，似乎多了好几个拷问自己的夜晚，具体问的什么实在是没脸说。 之前崇拜和喜欢的人脱单了npy还挺帅的，哎难过了好一段时间，特别是偶遇时，我心里真的好复杂好复杂……心想还要做一段时间队友，更复杂了…… 2020 我没想到 20 岁来的这么快，我也真正到了要面对些什么的年纪。先定个小计划： ~把谷歌 STEP 项目的简历投过去~ 被拒了 考下雅思或托福，学车 做一个拿得出手的开源项目 跟着导师还是得做些什么的对吧 把极客苏打做出来 去报吉他班，自己练真的没啥进步 少油少甜戒糖戒油炸，虽然我知道肯定不会执行 去一次日本或 HK（再乱也想去看看） 看一场彩虹合唱团的演出 多陪陪家人，外公外婆真的老了 当然了，思想上的一点点要求也得说说： 保持谦恭，对于我不知道的世界不应过多评价 DONT WORRY，生死面前皆为小事 BE OPEN，早点离开自己的那些固化思维，别一上来和你想的不一样就妄加批判 靠谱，凡事有交代、件件有着落、事事有回音 温热，别再被谁说是高冷怪了 最重要的可能还是： 改变这种一个人也能活的笨蛋思想 早点认清楚错过才不是什么美好，错过就是怂 + 自我安慰给你下的慢性毒药 赶紧脱单 还是很喜欢副部卡片上写的那八个字，虽然看起来平淡无力，但确实是我所能想到的，最棒的祝福： 万事胜意，平安喜乐。 2020 年祝好，晚安。 2020.01.02 01:35 ","link":"https://blog.g4.cx/post/2019-2020"},{"title":"初入强化学习","content":"原作 Medium 地址：https://medium.com/@adeshg7/introduction-to-reinforcement-learning-part-1-dbfd19c28a30 翻译文章式学习，感觉没有比我更奇葩的了……看看翻完能不能搞懂这些。 强化学习是什么？ 强化学习是一套帮你做决策的科学 我们在玩马里奥、战地这类通关式游戏的时候总要不断重复这样的步骤： 观察环境 → 做出行动 / 决策 → 分析刚刚做的决策是好是坏 就像你打马里奥一样，打多了输多了自然不会在同一个陷阱里摔两次。不断重复这样的步骤实际上在帮助我们记住在什么情况下应该 / 不应该做出哪样的行动，并且把这些行动串起来，怎样才能拿到游戏的最高分。 强化学习类问题 强化学习类问题大概长这样： 名词解释 奖励（Rewards）： 说是奖励不如说是得分，这就是衡量游戏玩的好不好的关键，强化学习最终也是为了让所获得的奖励尽量最大。 举个例子，你在玩坦克大战，得分和扣分可能是这样的： 成功击中敌方坦克：+ 1 分 敌方坦克被摧毁：+ 10 分 你 / 你的队友被打了：- 1 分 你的队友被打死了：- 10 分 目标： 通过分析，做各种判断和行动的形式让所获得的奖励尽量最大。不过奖励也有分短期和长期，田忌赛马了解一下。 状态： 指的是当前环境下的信息，这些信息一般是有助于去预测下一个状态是咋样的。 智能体（Agent）状态和环境状态： 智能体就代表一个玩家，玩家的状态多数只有他自己知道，状态的信息有助于强化学习去选择下一项操作——比如说你现在空血没魔，技能都还在 CD，这时候你选择 TP 泉水还是自信回头？ 环境会根据智能体所作出的行动来发生变化。不过环境的状态智能体不一定会知道，甚至有些情况下环境状态没啥用处。 马尔科夫状态： 马尔科夫状态（The Markov state）想告诉我们的就是：它认为未来只和当下有关，和历史无关。比如说你在跑 50 米，你下一秒摔不摔跤只和你当下有没有被石头绊倒或是踩到了自己的鞋带有关，至于从啥时候开始跑的跑前心情咋样通通都是历史。 马尔可夫状态真的很妙，它蕴藏的哲学可能是「历史塑造了我」，你的当下就是历史的积淀——我之前做过什么、喜欢什么、环境曾经带给我什么都会或多或少的呈现在现在的我身上，至于其他的都是无用信息，与决策无关。 用马里奥来总结一下这些名词大概就是： 环境：整个马里奥世界（水管、砖块、路上的金币 blabla） 状态：世界里某一个时间点的缩影（屏幕上只能显示世界的一小块） 智能体：你控制的马里奥 行为 / 动作：跳、蹲、向左、向右、发射（喷火马里奥有这个） 奖励：吃到 🍄了、顶到金币了都可以是奖励，其中金币就是瞬时奖励。 短期目标：成功降旗到了🏰 长期目标：打败了大魔王救出了公主 全知境界（Fully Observable Environment）： 意思就是智能体本身就拥有「上帝视角」，这又叫马尔科夫过程（Markov Decision Process） 智能体状态 = 环境状态 = 马尔科夫状态 未知境界（Partially Observable Environment）： 智能体需要靠之前的经验来一步步获取环境的各种信息，这又叫部分可知马尔科夫过程（Partially Observable Markov Decision Process）。就像 Dota 里的英雄没法知道整个地图的情况一样，除非你自己走到那里或者买眼。 智能体状态 ≠ 环境状态 强化学习智能体的组成部分 策略： 策略就是智能体整体的行为，它是一套能够让智能体得最高分的规则：抽象来讲就是给状态和动作建立联系。 值函数： 值函数是针对一个状态预期奖励（得分）的预测。比如现在走左边和走右边会有两种不同结局，那要怎么知道哪种结局是最好的呢？值函数量化了每种状态，让你的智能体知道应该往哪走。 整个公式得出的就是预测值，值 v 由参数 状态 s 决定，状态 s 遵循着 决策 𝛑、时刻 t 是指当前状态所处的时刻，下一秒则是 t + 1。 Gamma, 𝛄 系数 在我们关注当前 / 之后的状态时会起作用。如果只关注当前状态——𝛄 = 0；如果关注所有相关联的状态——𝛄 = 1，值越接近 1，状态的关联性越强。 模型： 模型是环境下智能体的表现，它能分成两种状态： 过渡：预测着下一个状态。比如给出小车的速度和位置，得出「切换」到下一个状态的概率。 奖励：预测的是瞬时奖励，当智能体做出动作时返回它所获得的奖励值。 不一定要构建模型，强化学习中也有很多高效的算法选择不使用模型这套理论。 强化学习智能体的各种类型 值驱动：没有确定的策略但却有非常直观的值函数，所有动作都取决于让值函数取到最大值。 策略驱动：有非常直观的策略但却没有确定的值函数，它关注的是 It sees how well it does by picking some actions and how much reward it gets. 无模型：没有模型意味着智能体不知道环境是怎么运作的，也没有确定的值函数和策略 模型驱动：使用模型及策略 / 值函数 Actor-critic：同时使用策略 + 值函数 ","link":"https://blog.g4.cx/post/3Q3S9-46P"},{"title":"Nicechord - 终止式和副属和弦","content":"终止式指的是乐句或一首曲子「最后几个和弦」的安排方式。 之前提到的和弦功能当中有讲，不稳定的和弦会有接到稳定和弦的趋势——也就是从「外面」回到「家」。 正格终止 G 即 5 级和弦，大调中的第三个正三和弦，任何一首歌曲都不可缺少。它起着对主和弦支撑的作用。乐曲的终止感就是由 5-1 这样的进行产生的。当然现代流行音乐特别是欧美音乐中不使用 5-1 终止的歌曲也很多，这正是流行音乐的特色，但 5 级和弦作为音乐的骨架和弦仍然不可动摇。 正格终止就是由五级和弦（V）接到一级和弦（I）的终止。也就是在 C 大调当中的 G(7) -&gt; C 半终止 既然五级和弦给人非常不舒服、不稳定的感觉，那么最后停在五级和弦（V）上的终止给人的自然是一种「意犹未尽、还没结束」的感觉。 其它 假终止： 本来应该是 V -&gt; I 的进行，却使用了其它方法及结束整个乐句。古典音乐常用 V -&gt; VI，有意想不到的悲伤、忧郁效果。 变格终止： 「教会版」终止，特指 IV -&gt; I 的进行，因为「阿门」的念法刚好和 IV -&gt; I 一样，所以又叫做「阿门终止」。 副属和弦 「副属和弦」（Secondary Dominant Chord）被用在两个和弦之间，起到「装饰」作用，让乐句听起来不单调，有起伏感。例如（加粗的为副属和弦）： C -&gt; B7 -&gt; Em C -&gt; E7 -&gt; Am C -&gt; D7 -&gt; G C -&gt; A7 -&gt; Dm 以上副属和弦都符合一个规则：「是从要接的那個和弦算起，往上五度音的屬七和弦」。E（Em） 往上五度音是 B，属七和弦就是 B7。 是不是有点像「终止式」当中 V -&gt; I 的关系？ 那如果想要再装饰一下「副属和弦」怎么办？既然有了「外面」、有了「家🏠」，自然也有「桥」和弦： 一般来说，在 V 和弦之前可以加入装饰性的二级和弦（「桥」和弦）。例如 C -&gt; Fmaj7： 加入「副属和弦」就是 C -&gt; C7 -&gt; Fmaj7 再加入一个二级的装饰和弦：C-&gt;Gm(7)-&gt;C7-&gt;Fmaj7（F 大调的二级和弦是 Gm） 上方：指比某一音更高的音，下方反之 ","link":"https://blog.g4.cx/post/nicechord-104"},{"title":"Nicechord - 音程名称","content":"音程就是指「音与音之间的距离」，就像尺子有刻度一样——音和音之间也有同样固定的标准。 度 例如 do-re-mi，从 do 到 mi 就是 3 度。 度一定是 整数，这也意味着实际上对音进行升降不会影响到音程。不管是 降 mi 还是 升 mi，只要它仍叫做 mi，那么从 do 到 mi 就还是 3 度。 那问题来了：既然降音和升音都是一样的，那它们之间的距离怎么表示啊？ 纯音程和大音程 在大调音阶里，每一个音和第一个音之间的距离，都叫做「完全」或「大」音程。我们把「度」分为两组： 1 4 5 8 纯（完全）音程（减 ⬅️完全 ➡️增） 2 3 6 7 大音程（减 ⬅️小 ⬅️大 ➡️增） 将 C 大调 do-re-mi-fa-sol-la-ti-do 和第一个音 do 来比较就会像上面这样👆。 举个 🌰，只要音之间的距离为 4 度，那么就属于「纯音程」，读作 纯 4 度。那么，比原先音程的距离要 窄 或者 宽 的就用其它的形容词来表示。 举个 🌰，do-降 mi 之间是 3 度，但 降 mi 比原本的音程要窄一个单位，那么就是 小 3 度。 ","link":"https://blog.g4.cx/post/nicechord-103"},{"title":"Nicechord - 和弦功能","content":"和弦的功能我想了想，似乎都可以归到人们常说的起承转合四个字当中。 我们来假定现在一首曲目只由单音的 do-re-mi-fa-sol sol-fa-mi-re-do 组成，前半段的进行给人一种从 do 出发一直往上爬的感觉，情绪逐渐上涨达到最高。可如果从中间断开——不弹奏后面的 sol-fa-mi-re-do 总是让人觉得不太舒服，就像是爬山「走到顶端」就呆在那不下来了一样。 把 do-re-mi-fa-sol-la-ti 映射到对应的和弦上来会是这样： 固定地，1 级和弦称主和弦、4 级和弦可称下属和弦，5级和弦也称属和弦。 了解这些有什么用呢？我们所说的谱曲和写歌，背后「和弦进行」的基本逻辑，就是从稳定的和弦再到不稳定的和弦，最后再到稳定的和弦。就好像是从「家」出发，到了杂乱的「外面」，跨桥经历千山万水之后终于再一次回「家」一样。 这也就是主和弦、下属和弦和属和弦的功能，合在一起就是完成了「起 ➡️ 承 ➡️ 转」最后再回到「合」 的进行。 C 即 1 级和弦，是用来明确调性的。一般大调的歌曲都以它开始，也以它结束。不过在曲子的中间可以尽量少用主和弦，否则老是给人以终止感，乐曲的进行也会很硬。 Dm 即 2 级和弦，是一个很柔和的和弦，它的最重要用途就是放在属和弦即 5 级和弦之前。而 5 级和弦则自然要回到1级和弦，所以很容易就形成了2-5-1的进行。这是一个极其常用的进行。 Em 即 3 级和弦，也是一个十分柔和的和弦。音乐的进行中有了她马上就会变得柔美而略带忧伤。1-3-4 的进行，也即在 C 大调中的 C-Em-F 是一个很常用的进行。乐曲中本来用 1 级和弦的地方有时可以考虑换成 3 级和弦，音乐立即就不强硬了。港台音乐中这种手法很常用。 F 即 4 级和弦，大调中的又一正三和弦，属于骨干和弦之一。它十分明亮，让人感觉心胸开阔，有一种一下子「飞」起来的感觉。我们听到的美国乡村乐和描写西部大草原和大峡谷的歌曲都使用 4 级和弦来表现。1 级和弦后面跟 4 级与跟 3 级和弦是绝对不同的。 G 即 5 级和弦，大调中的第三个正三和弦，任何一首歌曲都不可缺少。它起着对主和弦支撑的作用。乐曲的终止感就是由 5-1 这样的进行产生的。当然现代流行音乐特别是欧美音乐中不使用 5-1 终止的歌曲也很多，这正是流行音乐的特色，但 5 级和弦作为音乐的骨架和弦仍然不可动摇。 Am 即 6 级和弦，一个中性的和弦，如果把它作为主和弦那就是小调了。歌曲肯定会变得忧郁，悲伤。如果 6 级和弦出现在大调中的某些部分，那它起到的就是连接不同和弦的作用。6 级和弦象一座桥，它前面可以接几乎所有的和弦，后面也是如此。它可以是和弦的进行连贯，不呆板。1-6-4-5 是极为常用的进行，事实上就用这四个和弦就可以写歌了。 Bdim 即 7 级和弦，在流行音乐中很少用。因为它是减三和弦，有一种向里收缩的紧张感，一般只在某些特定进行中使用，或是为了根音的流动而使用。 Via: 【乐理】和弦的功能、变化、连接及编配 所以，与其给每一个和弦都定义一个功能，倒不如把现有的所有和弦都归类到「起、承、转」当中，只要遵循着最简单的 TDS 公式来谱曲就会很好听啦！ ","link":"https://blog.g4.cx/post/nicechord-102"},{"title":"Nicechord - 现代和弦代号","content":"和弦的定义变得越来越宽泛，比较基本的解释就是：三度音或三度音以上的堆叠。 和弦命名 三和弦 triad：三个音的和弦 「三和弦」之后命名规则发生变化——以「最后一个和弦音的度数」来命名，也就是： 七和弦 seventh：四个音的和弦（ex. 1 3 5 7） 九和弦 ninth：五个音的和弦（ex. 1 3 5 7 9） 十一和弦 ...：六个音的和弦（ex. 1 3 5 7 9 11） 十三和弦 ...：七个音的和弦（ex. 1 3 5 7 9 11 13） 十三和弦就是尽头了，因为第 15 度的音实际上与根音相同（也就是常说的高两个八度）。 和弦家族和代号 大（major）： 仅有大三和弦不加字尾。大调总给人一种明亮、愉悦的感受，所能听到的欢快的曲目基本上都选择了大调音阶。 小（minor）： 小三和弦也是哦。和大调相反，小调呈现出的是灰色、哀伤等负面情绪。 属（dominant）： 属和弦独特的效果在蓝调音乐中起到重要的作用。 之间的转换也有规律：例如大 7️⃣和弦转变到小7️⃣和弦，则需要给第 3️⃣、第 7️⃣度音降半音；转变到属 7️⃣和弦则需要给第 7️⃣度音降半音。 那么之后的音怎么办呢？不管和弦堆叠了几个音，其中的第 9️⃣、第十一、第十三度音都指「大调音阶」上的音。 和弦变换 挂（sus）： 不要 3️⃣度音，换成 4️⃣或 2️⃣度音（默认为 4️⃣）： 加（add）： 多弹一个音，在省略记法里偶数代表 add，而奇数就是 dominant 啦。 不弹（omit）： 转位和弦： 通常情况下和弦的根音都应该是「最低音」，比如说 C 的大三和弦 C E G 啦。那么反过来——最低音不是根音的和弦就叫「转位和弦」。例如E G c：这时 C 被抬高了 8️⃣度，E 虽然是最低音但根音还是c，这也就是 C/E（C on E） 和弦。 根音就是转位和弦的「原身」——某一个原位原味和弦建构的基础，它位于原位和弦的最下面（最低音），通过在上方堆叠音的方式来构成和弦。 转位和弦又叫分数和弦，分子为根音 / 分母为最低音。 Mark 一下这篇好文章：https://zhuanlan.zhihu.com/p/22211196 ","link":"https://blog.g4.cx/post/nicechord-001"},{"title":"ES6 - Set 和 Map 数据结构","content":"Set 集合 ES6 当中的 Set 和数学概念中的「集合」基本上是一致的。只不过它兼有普通 Array 的性质并且具备以下特点： 唯一：保证集合中各个元素都是不相同的 不发生类型转换：5 和 &quot;5&quot; 被视为两种不同元素，0 和 false 也是如此 NaN 等于自身：类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。（Via Set 和 Map 数据结构） 空对象不相等：所有的空对象在集合中都被视为不同的元素 其余的用法基本上和 Array 相同，利用 Set 集合很容易实现数学概念当中的「交并补集」，例如： // 并集 let a = new Set([2, 3, 4, 5]) let b = new Set([4, 5, 7, 8]) let union = new Set([...a, ...b]) // [2, 3, 4, 5, 7, 8] // 交集 let a = new Set([2, 3, 4, 5]) let b = new Set([4, 5, 7, 8]) let intersection = new Set([...a].filter(item =&gt; b.has(item))) // [4, 5] // 补集 let a = new Set([1, 2, 3, 4, 5, 6]) let b = new Set([1, 2, 3]) let c = new Set([...a].filter(item =&gt; !b.has(item))) // [4, 5, 6] 还多学到一个知识点：剩余参数的内部实现是 for..of，所以具有 Iterable 接口的对象都能使用剩余参数 ...。 new Set() 当中可传递的不仅仅是数组，而是所有可进行遍历的对象（比如字符串）： // 字母去重 let a = new Set(&quot;aaaaabbbcccccddd&quot;) // Set(4) {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;} Map 在实现 「键-&gt;值」对 时我们通常使用的是 Object，但 Object 的设计更像是实现了 「字符串-&gt;值」对 的模式，这意味着键名必须是一个合法的字符串（或是 Symbol）。Map 的设计则更加开放，键值均可为任意类型。 和普通 Object 的用法稍有不同，Map 需要以方法 set() 和 get() 对实例进行操作，例如： let a = new Map() let b = { foo: 'bar' } a.set(b, 'barbarbar') // 我怎么知道这有什么用呢，反正我是把一个对象和 'barbarbar' 联系起来了 a.get(b) // 得到 'barbarbar' 其实耐心尝试可以发现：Map 实际上是一个类似于 Hash 结构的存在，还是使用上面的例子，然后这样做会如何呢？ a.get({ foo: 'bar' }) // 提示不存在 这是因为 只有对同一个对象的引用，Map 结构才将其视为同一个键 （Thanks ruanyifeng）。换句话来说，以下的操作会出现的对应结果是： a.set('a', 'b') a.get('a') // undefined const keyA = 'a' a.set(keyA, 'b') a.get(keyA) // 'b' 那你可能会问了：a.set('a', 'b') 既然都没有报错，那我要怎么取到值啊？ 答：转换成其它形式呗（比如 Array, Object）~ Map 和 Array 之间有些暧昧的关系： From MDN：Map 与数组的关系，Map 的实现方法与构造二维数组有关。 var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]; // 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象 var myMap = new Map(kvArray); myMap.get(&quot;key1&quot;); // 返回值为 &quot;value1&quot; // 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组 console.log(Array.from(myMap)); // 输出和kvArray相同的数组 // 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组 console.log(Array.from(myMap.keys())); // 输出 [&quot;key1&quot;, &quot;key2&quot;] ","link":"https://blog.g4.cx/post/es6-set-he-map-shu-ju-jie-gou"},{"title":"PM2 使用方法之从抓狂到情绪稳定","content":"PM2 可以说是 Node.js 上为数不多称得上「好用」的进程管理软件了。之前疯狂 diss 它无非是因为文档写得太繁杂，Quick Start 介绍的内容又简单得过分。这次我还是以一个「普通用户」的角度来写写——我是怎么从情绪逐渐变态过渡到逐渐稳定的。 疯狂 diss ucloud，根本没感受到香港主机应该有的速度 懒人版：npm 一招流 多数使用到 PM2 的场景大概是在线上环境部署个 koa, egg.js 什么的，然而看了无比强大的 pm2 start 命令使用文档后大概只会和我一样懵逼…… 「请告诉我怎么运行 npm run dev 就好了。」 对于 package.json 已经定义好的 scripts 中的指令，假定你需要执行的是 npm run dev： cd koa2 # 假定文件均放在 ko2 目录下 pm2 start npm --name {name} -- run {script} 也就是 pm2 start npm --name koa-development -- run dev，一个 Koa 就启动好了。 一条命令实现开机启动 好了，无论是生产环境还是开发环境，上面的一条命令应该足够你启动绝大多数项目了。为了重启后还能够自动启动所有的进程，第二条命令是： pm2 startup [ubuntu | ubuntu14 | ubuntu12 | centos | centos6 | arch | oracle | amazon | macos | darwin | freebsd | systemd | systemv | upstart | launchd | rcd | openrc] 执行后将会保存当前所有进程，再也不用重启后还要费力执行好几遍命令了。 pm2 startup centos，重启一下喝杯茶，这下我看你还怎么 502…… ","link":"https://blog.g4.cx/post/pm2-shi-yong-fang-fa-zhi-cong-zhua-kuang-dao-qing-xu-wen-ding"},{"title":"你不知道的 JavaScript - 异步和并发","content":"（不得不说 YDKJS 作者的思路真的清奇，之前完全没有注意到这样的 point，一被点明后恍然大悟。好书，好书~ 什么是异步啊？ 来看下面的例子： // A setTimeout(function setTimeoutHandler(){ // C }, 1000 ); // B 这个是异步吗？看起来是的：语句按顺序执行，先是 A，然后在 setTimeout 处设置个时间点开始计时，然后直接执行 B。等到 1000ms 后再回去执行 setTimeoutHandler 的内容。 可是，以上的解释是不够全面的，且更让人窒息的是：在 ES6 出现之前，JavaScript 甚至没有一个完备的「异步」概念。（为什么呐？我也不知道，等我看到下卷我就知道了） 还是这些代码，我们再改改： // A 现在 setTimeout(function setTimeoutHandler(){ // 将来 }, 1000 ); // B 现在 明显，A 和 B 段都是「写出来就要马上执行」类的代码，属于程序需要现在运行的部分（跟 IIFE 木有关系，这词我乱造的）；而 Handler 内的代码则属于将来，是 1000ms 后需要运行的部分。 让我们再想想：setTimeoutHandler 里的内容真的会在 1000ms 后的那一时刻就被执行吗？ 答案是：要不就刚刚好，要不就比约定的时间慢——不确定。因为存在 事件循环。 事件循环 要解释上一问题其实很简单：只要弄清楚『在使用多个 setTimeout 这类「异步函数」的情况下，程序是如何执行的』这个问题，而首要的知识储备就是「事件循环」。 我们先联想下平常生活中的「异步应用」：银行办理业务。通常情况下我只需要先到前台的叫号机选择业务、拿一个号，号上还写着我前面有多少人、准备办理的是什么业务等等。需要注意的是：在叫到我准备办理业务之前这段时间里，我是相对自由可以做任何事情的。 转回当前的场景，我可以说：当前有多少人需要办理业务，就有多少个「号」。叫号机的「号」构成了一个事件队列，并且「先取号的人先办理业务（先进先出）」。 YDKJS 的伪代码很好地说明了 事件循环 是个啥东东： var eventsWaiting = [getBackToWorkAfter1000ms, ..., ..., ...]; // 事件队列，每一个数组的元素都是一个事件，并且（先进，先出） var event; while (true) { // 一有事件就要准备执行，所以是无限循环的 if (eventsWaiting.length &gt; 0) { // 如果此时存在事件 // 拿到队列中的下一个事件 event = eventsWaiting.shift(); // 现在，执行下一个事件 try { event(); } catch (err) { reportError(err); } } } 上一节里，我将程序的执行过程描述为：先是 A，然后在 setTimeout 处设置个时间点开始计时 blabla……。但 时间点 一词不够严谨——根据上面对异步的描述，实际上跟「时间」没半毛钱关系——我就是设定了一个「点」：就和取号机当中的「号」一样。 一定要清楚，setTimeout(..) 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻会摘下并执行这个回调。 这个无限循环的 while 语块里，程序会按照先来先得的顺序从队列中摘下一个事件并执行。这些事件就是你所定义的回调函数。 如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么 setTimeout(..) 定时器的精度可能不高。大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定。 ——《你不知道的 JavaScript》 为什么需要更高级的异步？ Mark 一下作者阐述「为什么需要更高级异步」的部分： 但是，我们真的能一心多用吗？我们真的能同时执行两个有意识的、故意的动作，并对二者进行思考或推理吗？我们最高级的大脑功能是以并行多线程的形式运行的吗？ 我们在假装并行执行多个任务时，实际上极有可能是在进行快速的上下文切换，比如与朋友或家人电话聊天的同时还试图打字。换句话说，我们是在两个或更多任务之间快速连续地来回切换，同时处理每个任务的微小片段。我们切换得如此之快，以至于对外界来说，我们就像是在并行地执行所有任务。 这听起来是不是和异步事件并发机制（比如 JavaScript 中的形式）很相似呢？！我不会在每次可能被打断的时候都转而投入到其他“进程”中。但是，中断的发生经常频繁到让我觉得我的大脑几乎是不停地切换到不同的上下文（即“进程”）中。很可能 JavaScript 引擎也是这种感觉。 所以通过回调表达异步的方式并不能很好地映射到同步的大脑计划行为。 如果我们（按照回调的方法）去计划一天中要做什么以及按什么顺序来做的话，事实就会像听上去那样荒谬。但是，在实际执行方面，我们的大脑就是这么运作的。记住，不是多任务，而是快速的上下文切换。 对我们程序员来说，编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考 / 计划的意识流对我们中的绝大多数来说是不自然的。 我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。 这就是为什么精确编写和追踪使用回调的异步 JavaScript 代码如此之难：因为这并不是我们大脑进行计划的运作方式。 ——《你不知道的 JavaScript》 竞态条件 考虑这个例子： var a; function aFunc() { a = &quot;I'm aFunc!&quot; console.log(a) } function bFunc() { a = &quot;I'm bFunc!&quot; console.log(a) } ajax( &quot;http://some.url.1&quot;, aFunc ); ajax( &quot;http://some.url.2&quot;, bFunc ); 这 aFunc() 和 bFunc() 到底谁先执行呢？不知道——谁也不清楚这 ajax 里回调的函数什么时候才会被执行（取决于谁先从给定的地址中得到相应），这就导致了程序的不确定性。 在 JavaScript 的特性中，这种函数顺序的不确定性就是通常所说的竞态条件（race condition），foo() 和 bar() 相互竞争，看谁先运行。具体来说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。 如何「规避」这种不确定性呢？最容易想到的一种方法就是「设置门闸」。 ","link":"https://blog.g4.cx/post/ni-bu-zhi-dao-de-javascript-yi-bu-he-bing-fa"},{"title":"ES6 - 箭头函数","content":"「箭头函数」相较于之前的「匿名函数」其优点是具有更简明的语法、可以隐式返回、不绑定this。 更简明的语法 &amp; 隐式返回 let a = [1,2,3,4,5,6,7,8,9] let aPlusOne = a.map(function(x) { return x + 1; }) console.log(aPlusOne); // (9) [2, 3, 4, 5, 6, 7, 8, 9, 10] 以上，map 的参数是 function(x) 这一个匿名函数，对数组的每一个元素 +1。有了 ES6，这一段代码可以这样修改： let a = [1,2,3,4,5,6,7,8,9] let aPlusOne = a.map( x =&gt; { return x + 1; }) console.log(aPlusOne); 也就是去掉了前面的 function 声明，将迭代器 x 直接写在 a.map 内作为参数。用一个箭头 =&gt; 指向函数块。 哦当然咯，如果匿名函数内的参数不止一个，那么之前的 a.map(x =&gt; ...) 还是需要将参数用括号包起来，像这样：a.map( (x,y) =&gt; ...) 实际上，如果这个「匿名函数」的作用能简单到只用一行 return 就搞定的话，以上代码还能再简单一点： let a = [1,2,3,4,5,6,7,8,9] let aPlusOne = a.map( x =&gt; x+1); console.log(aPlusOne); 箭头直接指向 return 后的表达式，这就是 隐式返回。 不绑定 this 我并不太懂这个「不绑定 this」更深层次是虾米意思……回头仔细看看，先照搬例子。 let Computer = { company: 'ThinkPad', name: 'Carbon X1', features: ['fast', 'inexpensive', 'squared-shape'], ram: '8G', printFeatures: function() { this.features.map(function(feature) { console.log(`${this.name} is ${feature}`); }) } } Computer.printFeatures(); // TypeError: Cannot read property 'name' of undefined 这里我们给 Computer 这个对象的 printFeatures 属性声明了一个匿名函数，但奇怪的是似乎取不到 this.name。 常规做法，我们会先给检查 this 是否绑定在 Computer 上： let Computer = { // ... printFeatures: function() { this.features.map(function(feature) { console.log(this); // console.log(`${this.name} is ${feature}`); }) } } Computer.printFeatures(); // undefined 实际上，console.log(this) 在 features.map 内的匿名函数里面，既不是直接赋值给对象上的属性，又没用什么 callback 之类的方法——导致 this 实际上指向的是 window 或者是 undefined（严格模式下） 在 ES5，可以使用这样的 Hack： // ... printFeatures: function() { var computer = this; this.features.map(function(feature) { console.log(`${computer.name} is ${feature}`); // Carbon X1 is fast ... }) } // ... 由于 var 是函数作用域，且 this 所指向的也是 Computer 这个变量，则自然代码可以正常运行。 在 ES6 则没有这么麻烦了，直接使用「箭头函数」就可以避免这种不必要的尴尬： // ... printFeatures: function() { this.features.map(feature =&gt; { console.log(`${this.name} is ${feature}`); }) } // ... 为什么呢？实际上，箭头函数根本「没有自己的 this」： this 对象的指向是可变的，但是在箭头函数中，它是固定的。this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。 箭头函数雷区 ES6 标准入门 - 阮一峰 箭头函数使用注意点： （1）函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 （3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 ","link":"https://blog.g4.cx/post/es6-jian-tou-han-shu"},{"title":"Understanding ES6 - 块级变量","content":"var 和 let 最大的区别在于其 作用域 不相同。前者属于「Function Scope 函数作用域」，后者则是「Block Scope 块级作用域」。 具体来上一个例子： if (1) { let a = 0; a = 10; } console.log(a); 这段代码返回的错误是 ReferenceError: a is not defined。这是因为 let 只对其所在的 语句块 内产生作用，然而 console.log 在 if 语句所包含的代码块之外。若想使其成功运行，可以这样改： let a = 0; if (1) { a = 10; console.log(a); } 此时 a 被正常打印，返回 10。这是因为 let a = 0 所在位置「没有语句块」，换言之：此时的 a 变量对全局生效。 那……var呢？上例子： if (1) { var a = 0; a = 10; } console.log(a); 此时 a 正常被打印为 10。这是因为var的作用域属于「函数作用域」，当然会正常生效。相较而言，以下代码就没办法正常运行了： function printVar() { var a = 5 console.log(a); } if (1) { printVar(a); // 5 a = 10; // ReferenceError: a is not defined console.log(a); } Var 雷区 Javascript 对 var 的设计略略相当奇葩，即使用var声明的变量可以在声明之前使用（变量提升）。看代码： console.log(a); // undefined var a = 100; 没有报错，直接返回 undefined。实际上以上代码等价于： var a; console.log(a); // undefined a = 100; 使用 var 绝对，绝对会给调试增加很多不必要的麻烦。更糟糕的是——var 可以被重复定义： var a = 100; console.log(a); // 100 var a = 200; console.log(a); // 200 正常返回，没有报错。而 let 的出现即完全避开了 var 在设计上的 雷区：没有变量提升（实际上是存在 TDZ）、不能重复定义（否则报错）、作用域更加严谨等等。 那 var 既然这么一无是处，为什么要存在呢？ 反正 Laracasts 的 Jeffery Way 是这样做的： NEVER USE VAR! ","link":"https://blog.g4.cx/post/understanding-es6-kuai-ji-bian-liang"},{"title":"Promise 迷你书笔记","content":"直接看 YDKJS 真的是暴露出了「我一点也不懂 JavaScript」的大问题……还是要先看看迷你书才能弄懂 YDKJS 上都说的是什么玩意…… 为什么要 Promise？ 上代码： console.log('Initialized.'); setTimeout(function() { setTimeout(then, 0) }, 2000) let then = function() { console.log(&quot;ALERT!&quot;) } console.log('I\\'m doing something before alert.') 这是用 setTimeout 实现的 Hack 版异步为了异步而异步代码，在输出 Initialized. 之后的两秒后输出 doing sth before alert.，之后则是 ALERT。 参见上节我不知道的 JavaScript - 还没写完异步和并发，用回调来写异步有以下几个显而易见的缺点： 反人类代码，不按顺序，理解困难 回调地狱，调试困难 ... 以上面的代码来说确实看不出有什么特别的缺点除了是我写的，来看看 YDKJS 的一个异步回调例子： doA(function() { doB(10); doC(function(){ doD(10); }, 10); doE(10); }, 10); doF(10); 猜猜这段玩意是怎么执行的？（为了便于理解，我给所有函数都多加了一个参数 10，代表延时 10 ms）(答案是：A-&gt;F-&gt;B-&gt;C-&gt;E-&gt;D，窒息)。所以说，JavaScript 相当有必要有一个更加高级的异步机制——这也就是今天的 Promise 和 Async。 什么是 Promise？ 我很喜欢吃 M记 的板烧鸡腿堡，假设我现在正在麦当劳的自动点单机上订餐，付款后点单机给你打印了一张编号为「1234」的凭条。几分钟后，前台的屏幕上显示着「1234 号请取餐」，这时你凭着点单机的凭条换来了服务员配好的板烧鸡腿堡。 「点单机制」就是 Promise 在生活中的一种应用。Promise 代替了 ES6 之前反人类的回调异步方式，并带领着 JavaScript 社区 Promise 化。 我们来解析下去 M记 点汉堡的例子： 那张「1234」的凭条就是一个餐厅对你的「保证」（Promise）——不管餐厅能不能做出来这个汉堡，最后都一定会给你一个答复 在「点餐-&gt;取餐」的过程中，我们（可能）会经历三种状态的转变：「等待取餐……」、「取到餐了！」、「服务员告诉我今天芝士汉堡卖完了」 我不觉得服务员会骗你说卖完了然后过几分钟再给你个汉堡，所以状态永远只能转变一次，并且转变后就不再变化了 同样的，Promise 正好也有三种与之对应的状态：pending（进行中） - 「等待取餐」、fulfilled（已成功） - 可以吃了和 rejected（已失败） - 卖完了。并且状态只能由 pending（未决议状态） 变为 fulfillled / rejected （已决议状态）（状态只能改变一次）。改变后将永远停留在这个状态不动——这时它就成为了不变值（immutable value），可以根据需求多次查看。 这样写出来的代码就好理解多了，我们来模拟下服务员备餐直至通知我们取餐的整个流程： let hamburger1234 = () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('快来取餐吧！') }, 50000) // 假设服务员准备一个汉堡需要 50 秒 }) } hamburger1234().then(value =&gt; { console.log(`状态：${value}`) }).catch(error =&gt; { console.log(error) }) console.log('您的订单号为 1234，服务员正在备餐，请稍等。'); /* 打印结果： 您的订单号为 1234，服务员正在备餐，请稍等。 状态：快来取餐吧！ */ ","link":"https://blog.g4.cx/post/promise-mi-ni-shu-bi-ji"},{"title":"你不知道的 JavaScript - This","content":"（之前一直不明白 Vue 组件里什么时候用 this 什么时候不用……果然基础不牢写什么都碰壁 什么是 this？之前我把它简单地理解为英文词义上的 this，也就是指向一个对象的本身。 果然我掉进了作者所说的坑里，再 Mark 一下定义以防忘记： 之前我们说过 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this 就是这个记录的一个属性，会在函数执行的过程中用到。 ——《你不知道的 JavaScript》 一句话：this 是函数被调用时发生的绑定，要想找 this 的绑定对象是谁，只需要找到这个函数是「在哪被调用的」（调用位置） 调用位置 上例子： function aFunc() { bFunc(); } function bFunc() { cFunc(); } function cFunc() { console.log(&quot;cFunc&quot;); } aFunc(); // 输出 cFunc 根据之前我们所知道的，程序依次执行 a/b/cFunc RHS 查询，最后输出 cFunc，这与我们预想的一样（词法作用域）。那么，各个函数的「调用位置」实际上就在当前正在执行的函数的前一个调用中。伪代码可以大概表示这一流程： aFunc(); -&gt; // aFunc(); 在哪被调用？在全局。所以： function aFunc() { // 调用位置：全局 // 调用栈；aFunc bFunc(); -&gt; // bFunc(); 在哪被调用？在 aFunc()。所以： function bFunc() { // 调用位置：aFunc // 调用栈：bFunc cFunc(); -&gt; // 以此类推…… } } 我上篇笔记瞎造了一个词叫「执行链」，在这里似乎也同样适用。我可以说：根据函数的执行链可以比较容易地判断出某个函数真正被调用的位置。 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。 另一个查看调用栈的方法是使用浏览器的调试工具：就本例来说，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。 因此，如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 ——《你不知道的 JavaScript》 默认绑定 独立函数调用是最常见的调用类型，上个例子： 我没有搞懂为什么这里的 this 指向的是 window，占坑待填…… function aFunc() { var a = &quot;I'm aFunc.&quot; function bFunc () { var a = &quot;I'm bFunc&quot; console.log(this.a) } bFunc(); } var a = &quot;I'm window!&quot;; aFunc(); // 输出 I'm window! 诶？为什么输出的是 I'm window？ 真奇怪，「执行链」的想法在这不靠谱！如上的插图即为这段代码的调试\b结果：This 是绑定在 Window 上的。 ","link":"https://blog.g4.cx/post/ni-bu-zhi-dao-de-javascript-this"},{"title":"ES6 - 模板字符串","content":"在 ES5 时代，拼接字符串需要这样写： let Computer = { company: 'ThinkPad', name: 'Carbon X1', features: ['fast', 'inexpensive', 'squared-shape'], ram: '8G' } console.log('My computer is a ' + Computer.name + ' and it has ' + Computer.ram + ' RAM.'); 实在是太惨了……就算是 PHP 也知道有个双引号能够解析字符串中的变量，而如今 模板字符串 即解决了这个问题：使用反引号括起需要解析的字符串，再将变量处理为 ${Variable} 这样的格式就可以达到无痛写字符串的效果： // ... console.log(`My computer is a ${Computer.name} and it has ${Computer.ram} RAM.`); // ... 实际上 ${} 并不仅仅能包裹变量——函数也行： let Computer = { company: 'ThinkPad', name: 'Carbon X1', features: ['fast', 'inexpensive', 'squared-shape'], ram: '8G', printIntroduction: function() { return `${this.name} and it has ${this.ram} RAM.` } } console.log(`My computer is a ${Computer.printIntroduction()}`); MDN： 模板字面量也可以使用三元运算符( condition ? true : false ) 和 嵌套 nested！ Ex. ES6 实现 Todos let Computer = { company: 'ThinkPad', name: 'Carbon X1', features: [ { feature: 'fast', truth: true }, { feature: 'inexpensive', truth: false }, { feature: 'squared-look', truth: true } ] } function renderFeatures() { return `${Computer.features.map(feature =&gt; `&lt;li&gt;${feature.feature} ${feature.truth ? '√' : '×' } &lt;/li&gt;`).join('')}` } const template = ` &lt;div&gt; Is ${Computer.name} worthy to be paid? &lt;ul&gt; ${renderFeatures()} &lt;/ul&gt; &lt;/div&gt; ` document.write(template) 输出： Is Carbon X1 worthy to be paid? - fast √ - inexpensive × - squared-look √ 带标签的模板字符串（Tagged Template String） MDN: 模板字符串的一种更高级的形式称为带标签的模板字符串。它允许您通过标签函数修改模板字符串的输出。 标签函数的第一个参数是一个包含了字符串字面值的数组（在本例中分别为“Hello”,“world”和&quot;&quot;） 第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式（在这里分别为“15”和“50”）。 最后，标签函数返回处理好的字符串。 Ex. 高亮标签 MDN： let Computer = { company: 'ThinkPad', name: 'Carbon X1', ram: '16G' } function highlight(strings, ...args) { let highlighted = args.map(arg =&gt; { return `&lt;span class=&quot;highlighted&quot;&gt;${arg}&lt;/span&gt;` || ''; }) let composed = '' strings.forEach((current, index, ar) =&gt; { composed += `${current}${highlighted[index] || ''}` }) return composed } let computerIntro = highlight`My computer is a ${Computer.name} and it has ${Computer.ram} RAM.`; document.body.innerHTML = `&lt;p&gt;${computerIntro}&lt;/p&gt;` ","link":"https://blog.g4.cx/post/es6-mo-ban-zi-fu-chuan"},{"title":"AORUS Gaming Box 从入坑到妥协 - Macbook Pro 不完全显卡坞笔记 [Win & macOS]","content":"终于还是狠下心买了块 1070……美名其曰跑数据炼丹，实际上配置好的第一件事就是 R6、下棋、吃鸡……从开学折腾到现在也算是调教得差不多了，写篇笔记免得以后忘掉。 你需要： 雕牌 AORUS Gaming Box + 随便一块显卡（我闲鱼淘的显卡坞 + 1070 一共 3200，跟全新的一样） macOS 10.13 High Sierra + win10（mojave 还没支持） purge-wrangler.sh：https://github.com/mayankk2308/purge-wrangler 外置显示器（内屏性能损耗严重，而且最好 DP 接口） 双系统 BOOTCAMP 本来双系统对 rMBP 来说也就那样……网上教程遍地都是，可我的 2018 款真的是碰上了各种让人心醉崩溃的小毛病。 ~~如果你正好也是 18 年才入的 rMBP，还想用 BOOTCAMP 装个双系统，还正好是 MacBook Pro (13-inch, 2018, Four Thunderbolt 3 Ports)。一定要记住安装 Win10 版本：Windows 10, version 1803 (Updated March 2018) (x64) 具体原因在弯弯的论坛上好像有见过，大概是因为 1803 的 2018 年 3 月 版本体积适中，又刚好是 rMBP 2018 第一个支持的 Win10 版本（说错了不怪我，弯弯说的）。两个条件缺一不可。 2019.08.16 更新：通过 BOOTCAMP 无法安装新版 Windows 10 的主要原因是install.wim 文件超过 4G，Boot Camp ISO Converter 这个小工具可以重新封装 ISO 文件，将里面的大文件切割成小文件，处理后即可正常安装无压力了。 macOS：配置、打驱动、SwitchResX 接下来的步骤：请保证显卡坞已正常连接至电脑 macOS 下面还是非常容易操作的，驱动齐全、前面又有这么多 eGPU.io 的玩家躺坑……基本上没什么难度。 按照 purge-wrangler.sh 的安装步骤一步步做好：Installation，或者直接开个终端执行以下命令： curl -q -s &quot;https://api.github.com/repos/mayankk2308/purge-wrangler/releases/latest&quot; | grep '&quot;browser_download_url&quot;:' | sed -E 's/.*&quot;browser_download_url&quot;:[ \\t]*&quot;([^&quot;]+)&quot;.*/\\1/' | xargs curl -L -s -0 &gt; purge-wrangler.sh &amp;&amp; chmod +x purge-wrangler.sh &amp;&amp; ./purge-wrangler.sh &amp;&amp; rm purge-wrangler.sh 如果你和我一样使用的是 N 卡的 10xx 系列，你需要执行 NVIDIA eGPUs 和 NVIDIA Web Drivers，purge-wrangler.sh 会根据你的显卡型号自动下载驱动，整个过程 5min 左右就能结束。同样，AMD 的当然就只需要选择 AMD eGPUs 啦。 如果「关于本机」处显示的是你的显卡，恭喜大功告成啦！ 几点注意 显卡坞不支持热插拔，作死会立即宕机 外屏的损耗要比内屏小得多 如果在关机状态下，正确的使用显卡坞方式为：在登录界面才插入显卡坞 如果在开机状态下，正确的使用显卡坞方式为：退出登录后插入显卡坞再登录 合盖后内屏依然在工作的解决办法 你会发现显卡坞工作时，无论怎么做 rMBP 的屏幕就是关不掉。浪费性能不说……合盖了有时候还找不到鼠标在哪太真实了。怎么解决呢，祭出 SwitchResX！ 显示器也能正常工作后，确保该项：Only SwitchResX can enable a disabled screen 为选中状态。然后在托盘选择 Color LCD 然后 Disable Display 就好啦！ Windows：打驱动、掐时间 相比之下 Win10 并不需要 purge-wrangler.sh 那样的脚本去帮助配置，你只需要好好把 BOOTCAMP 提供的驱动先安好，在 NVIDIA 官网上下载对应的显卡驱动（可能还有 CUDA）然后就好啦！ 才怪…… 你还需要掌握掐时间插入显卡坞的玄学技能，具体步骤是这样： 确保电脑是关机状态、显卡坞没插上 开机，紧盯屏幕 在蓝色微软 Logo 出现后立即插入显卡坞 如果你发现这时小圈圈转的比以前久了很多，甚至还带有一丢丢花屏的现象，恭喜你启动成功了！ 如果你的设备管理器里没看到显卡……恭喜你，从头再来一次吧！ 几点注意 一定要记得将 「NVIDIA 控制面板 -&gt; 管理3D设置」上的「电源管理模式」改为「高性能」；同理，Windows 控制面板下的电源管理计划也是如此，否则绝对能卡到怀疑人生 不知道是不是极少数个例：在拓展屏幕模式下（内外屏均工作）可以如丝般流畅，但一合盖就会出现问题：合盖后 内屏虽然能正常关闭、外部显示器正常工作，但……卡到怀疑人生 查了好久还是从 eGPU.io 上找到了答案：你还需要掌握掐时间合盖的玄学技能，具体步骤是这样： 如果你希望仅仅是外屏工作： 确保电脑是关机状态、显卡坞没插上 开机，紧盯屏幕 在蓝色微软 Logo 出现后立即插入显卡坞，与此同时，立即合盖！！！ 待系统进入登录界面后，不出意外就能用了 记得别作死又打开屏幕了 ","link":"https://blog.g4.cx/post/mbp-aorus-gaming-box"},{"title":"赴美游学","content":"短短一个月的美国游学之旅让我终身难忘。在拿到结业证书的那一刻，我才明白这段经历对我来说是如此重要。从前的我一闻美国，脑海中便是所谓的「资本主义国家」——「金钱」、「权利」、「虚假的自由」，对这个允许人民配备枪支、媒体四处抹黑中国的国家没有一丝好感。 但是，当我置身于时代广场的热情与喧嚣，当我置身于华盛顿的雄伟与厚重，当我置身于波士顿的宁静与和谐，我逐渐了解到：原来，真正的美国，与我想象的完全不同。 之前为了应付学校要求而写的报告，现在看起来好尬好尬。 富有深度的学生日报 我了解到，波士顿大学（https://dailyfreepress.com）和哈佛大学（https://www.thecrimson.com）均有独立的「学生日报」社团，它们都仅由学生自主管理，负责报道每天学生的活动动态并尽可能保持中立。可以说，「学生日报」社团是一类以学生为代表，专为学生发声的平台。 杭电校内的匿名留言墙（杭电表白墙）成立的初衷本是丰富学生课余生活，但每当学校有重大事件发生时，该留言墙也能成为学生们讨论与思考的「论坛」。前段时间的「知乎事件」引起了学生们的注意，大家便自发地参与进讨论问题的行列中来，在留言墙上直播学校的跟进及处理情况。但是，留言墙天生的社交属性并不足以成为正式的学生信息发布平台，或许引入学生日报这一模式，一可以拉近学校管理层与学生的距离，不依靠其它社交平台（如知乎贴吧）去了解学生的情况；二是能够引导学生独立思考，积极为学校建言献策；三是成为学生团体当中的「风向标」，由社团（学生群体）报道活动动态或学生的优秀事迹，更能够鼓励其他同学向其看齐，起到良好的导向作用。 灵活的授课方式 / 富有深度的话题讨论 Shawn Mullet 教授在第一天为我们简单介绍课程后所问的是：「你们对课程的安排有什么意见吗？我会根据你们的反馈来调整教学内容」。他随后采纳了同学们的建议，并承诺将在今后的课程中添加更多有关语音语调的内容。 反观国内教育，我相信绝大部分高校并没有「灵活教学」的意识。试想，倘若按照学生要求：在线性代数课程中着重讲解机器学习常用的数学知识，在 Java 程序设计课程中穿插更多富有实践性的，企业级程序设计的内容，而非照本宣科，按图索骥——我相信，这样学到的知识将不再局限于书本。 除此之外，Shawn Mullet 根据我们的情况（三周的授课时间，并不积极回答问题的中国学生）对授课方式和内容进行了调整。抛弃了传统的 PPT 式、灌输式教学，返璞归真——教授的每一堂课都与我们像是在「聊天」，以苏格拉底式的风格提出问题，让同学们自由发言。最为精妙的是，每一次聊天的话题均能在无意间被引导至课程的主题：「中美的民族文化」由「一个在美国生活的中国孩子算是哪国人」引出；「中西方文化差异」由「为什么美国人爱喝冷水」引出。 有一次他直接抛开晦涩难懂的课程阅读材料，用了一天的时间与我们讨论：除了语法与词汇，什么才是阻止你口语获得成长的最大障碍？Shawn 教授坦言，绝大部分的美国教师在给中国学生授课时，最不能理解的事情便是：为何来自中国的学生不爱在课上提问题？大多数同学认为：最大的障碍就是害怕「Losing face」，因为我们成长在一个无法犯错的环境。或许正是因为一贯施行的教育模式，让「羞于出错」的思想根深蒂固于脑海。 他时常让同学们上台分享自己在美国的「糗事」，时常用半开玩笑的口吻告诉我们：「可是最后，你们都成功地活下来了啊！」。走出语言的舒适区会让你感到尴尬和困扰，但战胜自己之后——你一定会收获颇丰。 公共设施的精心设计与管理 「Students’ Center」前是一片充满「仙气」的小石林。步入初秋的波士顿仍然绿树葱茏，再加上如云朵一般水雾的点缀——你此刻步入的，何不正是仙境。 各具特色的「旧式城堡」和前卫科研设施相互交织，竟在校园内展示出了少有的和谐美。 哈佛为各学科领域提供了最为优厚的科研条件，随处可见超现代化的实验室和先进设施。 哈佛虽饱经沧桑，但带给它的决不是岁月的衰败感——无论精神或是物质。在每一间教室使用结束后，将有专门的保洁人员对教室内设施进行清洗消毒，然而多数高校对教室设施的维护仅限于门窗和多媒体设备。不仅如此，放眼整个美国（纽约、波士顿和华盛顿），多数建筑物的墙体都能保持干净，对掉漆掉色或污垢等问题会有专人定期处理。我想，这是令历史并不悠久的美国仍能保存文化底蕴而又散发活力的一个重要原因。 富有深度的校园雕塑 麻省大道旁，凝望着庄严的 7 号大楼的，是一个用数字和字母连起来的的塑像——他的名字叫「Alchemist」，学生们笑称其为「脑洞大开」。这些看似杂乱无章的线条竟组成了一个屈膝而坐的「思考中的人」。某位教授曾说：「以前我们想到技术，总是在谈人工智能，怎么让机器变得更聪明，让他们像人一样思考。我认为这是一个错误的方向。未来我们应该做的是，怎么利用技术让人变得更聪明，更强大，更独立。」思考者背后，或许意味着更聪明、更强大、更独立的人类未来。 不完美的美国 大家各自以小组的形式发表自己在美国的有趣见闻。大家看到了身为发达国家的先进一面：政府对教育的充分重视、街头随处可见专为残障人士的贴心设计；也看到了稍显不合理的一面：不够人性化的银行上班时间、以信用卡签名为主的交易方式……这让我们得以变换角度去思考问题：倘若在中国，这些「美式规则」是否也同样值得带回国内推广呢？国外的月亮并非总是圆的，在批判思考后取其精华才是正道。 知者不言，言者不知？ Shawn 教授在最后一节课上提到：「哈佛的学生有一个特点：Saying without knowing，而 MIT 的学生正好相反」，他认为，哈佛比 MIT 更注重「包装和为自己做营销」，在各地的演讲台上大放光彩；而 MIT 的学生往往「沉默寡言」，但学术成果往往令世界震惊。 中国有一句古话：「知者不言，言者不知」，我想大概就是 Shawn 教授眼下哈佛与 MIT 学生的真实写照。这是世界两所顶尖大学所走的，风格截然不同的路：言大于知，能让世界先一步了解你，但毫不知晓便发表言论何不是在「说胡话？」；知大于言，能让世界后一步了解你，但学富五车而沉默寡言的生活何不不遇伯乐？ 身为某国人，意味着什么？ Shawn 教授曾提过一个问题：「作为中 / 美国人意味着什么？」直至讨论结束我依然没有办法得出满意的答案。但令我庆幸的是，我明白了：永远不应该使用狭隘的外貌亦或是血统来厘清中国人的真正含义。 依我愚见，中国人意味着「传承」二字。回望上下五千年，我相信每一个能称之为「中国人」的个体都一定做到了：无论他身在何方，心中都始终愿意接受着中国文化，始终愿意为继承和发扬中国文化而奉献辛勤。或许就像 Shawn 说的那样：「Culture is the software of our mind」——中国人这一概念与文化紧紧相连，如软件般虽独立于物质之外，却在精神上根植脑海。此时，无关国籍，无关种族。 禁枪，或不禁枪？ 「美国最差的制度是什么？」Shawn 从与我们的闲聊中引出政治家们争论已久的话题：禁枪，或不禁枪？恕我直言，我一度认为美国是一个极度不安全的国家——枪支商店多如繁星，约 40% 的美国人会为自己配备武器。 但 Shawn 用一连串统计数据和他的自身经历为我们重新塑造了对美国的认知，他引导大家用从多角度思考「枪支」对于人们的意义。禁枪，或不禁枪，答案是什么？Shawn 告诉我们：支持配枪的人们，他们对「枪支」的热爱早已成为其身份的一部分；反对配枪的人们也是。禁枪，或不禁枪，永远没有标准答案。但正是无数人对这类问题的不断探索，国家才能更加接近人们所想象的样子。 让人无法爱上的唐人街 见它第一眼，我实在是喜欢不上这个地方。恕我直言，波士顿的唐人街似乎与整个城区格格不入：被小商贩挤得水泄不通的人行道，遍地烟蒂纸屑的环境告诉着我三个字——「脏乱差」。从唐人街发展历史可以看出，它的存在仅仅是为了让更多的华人体面地生活，再者，唐人街给美国带来了很多的廉价劳动力和税收收入，自然也不会因为卫生这点问题而强制插手在美华人的圈子和生活。 嘴上摒弃着这里，但我想，兴许没有人会真的离开这里：因为这是身在异国他乡，唯一能找到归属感和亲切感的地方——旧时代的广式街道，家乡熟悉的中国符号……兴许，所有的唐人街都与其外面的世界格格不入——因为有且仅有这一个地方能做到，为在外漂泊的同胞提供来自民族的一丝温度。 傍晚，唐人街依然熙熙攘攘，马路上摩肩接踵。 ","link":"https://blog.g4.cx/post/to-usa"},{"title":"解决 Yarn / NPM 从 GitHub 下载 Node-SASS 导致安装速度过慢的问题","content":"这问题困扰了我好久……明明 Registy 用的已经是 http://registry.npm.taobao.org，然而安装过程中还是会出现各种卡在 Download from github 的尴尬问题。 Mark 一下解决方法： Registry 更换淘宝源 npm : npm config set registry http://registry.npm.taobao.org yarn : yarn config set registry http://registry.npm.taobao.org 指定 Sass-binary 获取地址 npm： npm config set sass-binary-site http://npm.taobao.org/mirrors/node-sass yarn： yarn config set sass-binary-site http://npm.taobao.org/mirrors/node-sass 再也不用输一次 yarn 还要顺带着把 Proxifier 带上了…… ","link":"https://blog.g4.cx/post/jie-jue-yarn-npm-cong-github-xia-zai-node-sass-dao-zhi-an-zhuang-su-du-guo-man-de-wen-ti"},{"title":"MacroTasks 和 Microtasks","content":"Jake Archibald 版本 Tasks, microtasks, queues and schedules Macrotasks 按序执行，浏览器会在 Macrotasks 之间执行渲染。 Microtasks 按序执行，在下面情况时执行： 在每个回调之后，只要没有其它代码正在运行。 在每个 Macrotask 的末尾。 何幻版本 [JavaScript] Macrotask Queue 和 Microtask Queue V8 实现中，两个队列各包含不同的任务： Macrotasks: script (整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering Microtasks: process.nextTick, Promises, Object.observe, MutationObserver 执行过程如下： JavaScript 引擎首先从 Macrotask queue 中取出第一个任务， 执行完毕后，将 Microtask queue 中的所有任务取出，按顺序全部执行； 然后再从 Macrotask queue 中取下一个， 执行完毕后，再次将 Microtask queue 中的全部取出； 循环往复，直到两个 queue 中的任务都取完。 可以发现，两位大神的版本略有不同，但总体分析的思路是一致的。只是 Jake Archibald 更指出在 JavaScript 栈已空时——Microtasks 同样也会按序执行。（Although we're mid-task, microtasks are processed after callbacks if the stack is empty） 几个小测试 专栏: Promise只能进行异步操作？ 专栏: Promise只能进行异步操作？ var promise = new Promise(function (resolve){ console.log(&quot;inner promise&quot;); resolve(42); }); promise.then(function(value){ console.log(value); }); console.log(&quot;outer promise&quot;); 结果为：inner promise, outer promise, 42。 流程如下（Macrotask 简称 MA；Microtask 简称 MI，下同）： (script 整体代码) 添加 MA，此为 MA 队列中第一个任务，开始执行。 输出 inner promise（Promise 决议前内容立即执行） resolve(42) (Promise then) 添加 MI，操作被挂起 输出 outer promise (script 整体代码) MA 执行完毕，接下来处理刚刚排在队列中的 MI： 输出 value，决议内容为 42 Tasks, microtasks, queues and schedules Tasks, microtasks, queues and schedules （Jake 大神网站里的动态示意图真的很有用 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); 结果为：script start, script end, promise1, promise2, setTimeout 流程如下： (script 整体代码) 添加 MA，此为 MA 队列中第一个任务，开始执行。 输出 script start (setTimeout) 添加 MA，排在「script 整体代码」的后面，此为 MA 队列中第二个任务，操作被挂起 (Promise then) 添加 MI，操作被挂起（链式调用，then 链节之后的所有操作均被挂起） 输出 script end (script 整体代码) MA 执行完毕，接下来处理刚刚排在队列中的 MI： 输出 promise1 (Promise then) 添加 MI，操作被挂起 由于第一个 MA 已经处理完毕，继续处理 MI 输出 promise2 MI 处理完毕，接下来处理 MA 队列中第二个任务，开始执行。 输出 setTimeout。 Tasks, microtasks, queues and schedules - Boss Fight Tasks, microtasks, queues and schedules - Boss Fight 点击一下 inner 部分，console 会输出什么呢？ &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; // Let's get hold of those elements var outer = document.querySelector('.outer'); var inner = document.querySelector('.inner'); // Let's listen for attribute changes on the // outer element new MutationObserver(function() { console.log('mutate'); }).observe(outer, { attributes: true }); // Here's a click listener… function onClick() { console.log('click'); setTimeout(function() { console.log('timeout'); }, 0); Promise.resolve().then(function() { console.log('promise'); }); outer.setAttribute('data-random', Math.random()); } // …which we'll attach to both elements inner.addEventListener('click', onClick); outer.addEventListener('click', onClick); 结果为：click, promise, mutate, click, promise, mutate, timeout, timeout 执行流程如下： (处理用户点击事件) 添加 MA（编号 #1），此为 MA 队列中第一个任务，开始执行。 输出 click (setTimeout) 添加 MA（编号 #2），操作被挂起 (Promise then) 添加 MI，操作被挂起（$1） setAttribute 操作 setAttribute 操作被 MutationObserver 监听到，添加 MI，MutationObserver 回调操作被挂起（$2） MA 操作结束（此时 JS Stack 为空！即在响应下一个 outer 的 onClick 之前无代码可以运行），开始执行队列内的 MI： 输出 promise 输出 mutate 事件回调，编号 #1 的 MA 又被重新执行了一次，同 1, 2 步（inner 在 outer 内，先处理 inner 事件后处理 outer 事件）。 (setTimeout) 添加 MA（编号 #3），操作被挂起 MA 操作结束，开始执行 #2：输出 timeout MA 操作结束，开始执行 #3：输出 timeout 🙂我很窒息。 Tasks, microtasks, queues and schedules - Boss's angry older brother 还是上面的代码。这次不同的是我们不直接点击，而是在 Console 输入： inner.click() 会发生什么呐？ 结果是：click, click, promise, mutate, promise, timeout, timeout 执行过程如下： （我真的不想写了，Tasks, microtasks, queues and schedules - Boss's angry older brother 头有点大，:big head:。 🙂。 ","link":"https://blog.g4.cx/post/macrotasks-he-microtasks"},{"title":"你不知道的 JavaScript - 作用域 / 左右值引用 / 词法作用域","content":"编译原理 对于传统的编译型语言来说，「编译」大致需要经过三个步骤：分词、词法解读、生成机器阅读的「机器码」。JavaScript 稍微特殊些，因为它会在每次浏览器访问时（大多数情况下）才进行编译。 分词：引擎会对代码逐行进行「分词/解构」。以let a = 1;为例，分词后的结果即是let、a、=、2、;，可以发现——空格在多数情况下决定着分词的位置。 解读：分词后的结果将会被转换成更为抽象的一个个元素，分别对应着 AST （抽象语法树）上的一个个节点——实际上就是「解读」这些「词」背后代表的真正含义：let（声明类型）、a（变量标识符）、=（操作符）、2（值 &lt;- NumericLiteral 整型字面量）、;（语句结束） 生成「机器码」 当然 JavaScript 的编译过程没有上述这么简单，但在大部分情况下：JavaScript 代码片段通常都要进行编译（并在编译前的短时间内用尽各种优化的方法），而后立即执行。 作用域 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 ——《你不知道的 JavaScript》 作用域类似于数学函数中的「定义域」，字面理解：使语句得以「生效」的区域。 在上述的「编译原理」里，实际上「生成机器码」这一过程大有文章——「作用域」就有参与其中。 还是以 let a = 1为例，在一一分词解读结束后，引擎将会预先确定这行代码是否「可以生效」——不能生效的情况有很多种，例如之前已经有一个名为 a 的变量被声明啦之类的。这一类类条约倘若其一不能实现，那么编译器就采取忽略或者抛出异常的行动。 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果不是，引擎会继续查找该变量。 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！ LHS Reference / Look-up、RHS Reference / Look-up （前段时间同学问我什么是左右值引用（C++），我还相当敷衍地跟他说看看就好，这下打脸了…… JavaScript 的左右值引用 / 查询似乎和 C++ 还是有一定区别的。但是万变不离其宗…… 我们试着以三个简单的例子，从字面角度来理解 L/R-HS 引用： LHS 查询：let a = 1，这时候 a 所被执行的是赋值操作，然而 a 之前等于多少跟我没啥关系，这就是对 a 的 LHS 引用，所做的是 LHS 查询。 RHS 查询：let a = b，这时候我需要先知道 b 的值是什么（b 等于多少跟我关系很大），才能让 a 正确地被赋予新值，这时候对 b 所做的就是 RHS 查询（事实上这一例子存在 LHS、RHS 两种查询，见例 1）。 RHS 查询：console.log(a)，这时候我需要知道的是 a 的值（a 等于多少跟我关系很大），然后打印到控制台上，这就是对 a 的 RHS 引用，所做的是 RHS 查询。 通过观察发现，RHS 并不是看起来那样的什么赋值符号左右分别就是 LHS RHS 查询——RHS 查询更像是一种「非左侧查询」。 最后上个例子 来自 YDKJS，确实想了蛮久…… function foo(a) { let b = a; return a + b; } let c = foo( 2 ); 存在的查询有： foo(...) RHS 查询，返回一个值准备赋值 c a = ... LHS 查询，隐式查询，将 2 赋给 foo 函参 a ... = a RHS 查询，返回 a 的值准备赋给 b b = ... LHS 查询，同理 a + ... RHS 查询，返回 a 的值准备相加 ... + b RHS 查询，同理，对应「1」 c = ... LHS 查询，同理。 总计 3 个 LHS 查询，4 个 RHS 查询。 哦，那我知道这些干嘛？ YDKJS 上的结论非常清楚： 不成功的 RHS 引用 —— ReferenceError 不成功的 LHS 引用 —— 隐式创建变量（非严格模式下）/ ReferenceError（严格模式下） 了解 RHS 和 LHS 的概念将有助于我们对语言运行机制的理解，以一个 ES5 非常经典的例子做述： console.log(a) var a = 10 console.log(typeof a) /* 返回： undefined number */ 可以说是相当坑爹了：我都没声明变量，哪来的输出？ 根据前一节「作用域」的概念：当 console.log(a) 被执行时：\b编译器将首先在当前作用域内寻找是否有一个名为 a 的玩意（Literal 字面量）。如果实在没有，则编译器就会继续向上查找，直至找到为止（从代码书写的角度上看，就像洋葱一样从里到外）。完全没有呢？那么就在「全局作用域」内创建一个名为 a 的变量。 词法作用域 / 动态作用域 YDKJS 上的例子： function aFunc () { var a = 3; bFunc(); } function bFunc () { console.log(a); } var a = 2; aFunc() // 结果为 2 为什么结果不是3呐？是因为 JavaScript 本身就是一门使用词法作用域的语言，根据上述「从里到外的洋葱查找」，其过程是这样的： 全局作用域内定义 a = 2 aFunc() 被执行，在 aFunc() 作用域内声明另一个 a = 3 bFunc() 被执行，遇到了 RHS 查询 console.log(a)。咦，a 是啥？ 为了搞清楚 a，编译器在确定 bFunc() 作用域内找不到 a 的情况下将「向上查找」——也就是查找「全局作用域」 当然：如果 JavaScript 是一门使用 动态作用域 的语言，其结果就为 3：编译器查找的方向就从上述的「作用域链」（词法作用域语言）变成了「执行链」（这词我瞎造的）——\b也就是调用栈（动态作用域）。 词法作用域（静态作用域） 在书写代码时即被定义，而 动态作用域 在运行时才根据情况被确定。也就是说：词法作用域关注作用域在何处被声明，动态作用域关注作用域在何处被使用。 YDKJS 上还有一个 欺骗词法作用域 的介绍，感觉比较简单明了就不记了。总而言之就几句话： eval() 和 with() 之类函数在运行时才能确定词法作用域，造成作用域在运行时被修改的现象（欺骗词法作用域） 这类「欺骗函数」让 JavaScript 引擎难以在编译阶段做性能优化——甚至干脆就不优化了，代码性能大大下降（谁知道 eval() 传递的是什么东西） 这类「欺骗函数」既不安全又难以正确使用 最佳实践——别用它们。 ","link":"https://blog.g4.cx/post/ni-bu-zhi-dao-de-javascript-zuo-yong-yu-zuo-you-zhi-yin-yong-ci-fa-zuo-yong-yu"},{"title":"Laravel Socialite 实践","content":"用半天假期顺便梳理了第三方登录的流程，使用的是超神的 Socialite。 我原本可以再偷点懒——直接使用别人处理好的脚手架不就省事了咩，所以之前考虑做项目时就直接选择了 Laravel-Auth 来开发——但最后还是忍不住重构了。 流程 以 QQ 登录为例： 当用户点击使用社交账号登陆后，将跳转到第三方登陆的登陆界面。 若登录成功，服务商会向网站所提供的 callback 地址传递该用户的相关信息（昵称、用户名、QQ 等级 blablabla）。并附有表示该账号的唯一 ID。 开发者再根据服务商返回的信息，与网站用户之间建立相应联系。如下图（Via 人人都是产品经理）： 思路 需要实现功能： 登录页面点击相应图标，即可使用对应平台登录 / 注册 已注册用户可以在个人中心绑定 / 解绑第三方平台账号 实现思路： 用户在登录页面点击「社会化登录」按钮 -&gt; 用户授权登录完成 -&gt; 接收到服务商返回的用户信息： 如果数据库内存在一个用户的 Email 可以与第三方平台提供信息相匹配（以下简称「对应关系」），而他却没有绑定该账号 -&gt; 跳出，让用户直接使用密码登录 数据库内没有匹配的对应关系 -&gt; 视为新用户，直接注册 数据库内已有匹配的对应关系 -&gt; 直接登录 用户在个人中心页面点击「绑定账号」按钮 -&gt; 用户授权登录完成 -&gt; 接收到服务商返回的用户信息： 数据库内没有匹配的对应关系 -&gt; 绑定 数据库内已有其它用户占用此第三方账号 -&gt; 报错 首先建立一个新模型 Social 用于说明 User 和各第三方平台提供数据之间的关系。数据表可以这样设计： $table-&gt;increments('id'); $table-&gt;integer('user_id')-&gt;unsigned()-&gt;index(); $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade'); $table-&gt;string('provider', 50); $table-&gt;text('social_id'); $table-&gt;timestamps(); social_id 对应服务商 provider 返回的唯一 ID。 路由定义： &lt;?php Route::get('/social/{provider}', ['as' =&gt; 'social.redirect', 'uses' =&gt; 'Auth\\SocialController@getSocialRedirect']); Route::get('/social/{provider}/callback', ['as' =&gt; 'social.handle', 'uses' =&gt; 'Auth\\SocialController@getSocialHandle']); Route::get('/social/{provider}/unbind', ['as' =&gt; 'social.unbind', 'uses' =&gt; 'Auth\\SocialController@getSocialUnbind']); SocialController.php： &lt;?php // .... public function getSocialRedirect($provider) { return Socialite::driver($provider)-&gt;redirect(); } public function getSocialHandle($provider) { $socialUser = Socialite::driver($provider)-&gt;user(); $matchedSocial = Social::where('provider', $provider)-&gt;where('social_id', $socialUser-&gt;id)-&gt;first(); // 1 情况 if (\\Auth::guest() &amp;&amp; !empty($matchedSocial)) { return redirect('login')-&gt;withErrors('对应用户并未绑定社交账号，请使用密码登录。'); } if (empty($matchedSocial)) { // 4 情况 if (\\Auth::user()) { $this-&gt;socialDataRecord($socialUser, \\Auth::user(), $provider); myflash()-&gt;success('绑定成功'); return redirect()-&gt;route('users.edit', \\Auth::user()); } // 3.ii 情况 // 判断是否已有用户名，如果有，则随机化用户名 $username = $socialUser-&gt;name; $usernameCheck = User::where('name', $username)-&gt;first(); while (!empty($usernameCheck)) { $username .= str_random(6); $usernameCheck = User::where('name', $username)-&gt;first(); } // 对不提供邮箱的第三方平台的 Hack if (!$socialUser-&gt;email) { $email = 'missing' . str_random(10); } else { $email = $socialUser-&gt;email; } // 写入新用户到数据库 $user = User::create([ 'name' =&gt; $username, 'email' =&gt; $email, 'password' =&gt; bcrypt(str_random(40)), 'signup_ip_address' =&gt; $this-&gt;request-&gt;ip(), 'role_id' =&gt; 2, 'activated' =&gt; true ]); $this-&gt;socialDataRecord($socialUser, $user, $provider); auth()-&gt;login($user, true); myflash()-&gt;success('登录成功，请尽快完善您的个人信息。'); return redirect()-&gt;route('users.edit', \\Auth::user()); } if (\\Auth::user()) { myflash()-&gt;warning('绑定失败，账号已被占用。'); return redirect()-&gt;route('users.edit', \\Auth::user()); } auth()-&gt;login($matchedSocial-&gt;user, true); return redirect('/'); } public function getSocialUnbind($provider) { $user = \\Auth::user(); $user-&gt;social()-&gt;where('provider', $provider)-&gt;delete(); $user-&gt;unsetMeta($provider.'_nickname'); $user-&gt;save(); myflash()-&gt;success('解绑成功'); return redirect()-&gt;route('users.edit', \\Auth::user()); } public function socialDataRecord($socialUser, $user, $provider) { $socialData = new Social(); $socialData-&gt;social_id = $socialUser-&gt;id; $socialData-&gt;provider = $provider; $user-&gt;social()-&gt;save($socialData); $user-&gt;setMeta($provider.'_nickname', $socialUser-&gt;nickname); if (!$user-&gt;display_name) { $user-&gt;setMeta('display_name', $socialUser-&gt;nickname); } $user-&gt;save(); } ","link":"https://blog.g4.cx/post/laravel-socialite-shi-jian"},{"title":"初试 Laravel 支付宝支付开发","content":"过来水一篇，这次使用的是 Yangsongda/Pay，不用写各种拼字符串的代码真是太幸福了。 想跑通整个支付流程，提供订单号、AK、SK 这类资料也已经是老生常谈了。不过最让人感到一头雾水的应该是 notify_url 和 return_url 两个概念。 官方版 notify_url：对于 PC 网站支付的交易，在用户支付完成之后，支付宝会根据 API 中商户传入的 notify_url，通过 POST 请求的形式将支付结果作为参数通知到商户系统。 return_url：支付宝处理完成后，浏览器当前页面自动跳转回商户网站中指定页面的路径，同时返回订单信息。 什么鬼……最后折腾了半小时才弄懂支付宝文档想说什么。 人话版 Return URL 功能：买家支付成功后跳转到自己网站的「支付成功」页面。 Notify URL 功能：减少掉单几率（听说是 0.0001%）、帮助网站主及时处理交易成功的订单（我乱说的） 流程： 用户根据步骤依次下单、支付且支付成功后，支付宝会将订单状态更改为：「等待发货」（trade_status=WAIT_SELLER_SEND_GOODS） 同时支付宝将不断以 POST 的形式向所提供的 notify_url 发送数据，包括给客户生成的交易订单号 out_trade_no 还有支付金额 total_amount 等等。这时就应借此机会来校验订单金额是否正确、交易订单号是否与网站上的相符等等，还有就是做发货之类的任务分发 当以上操作全部结束时，应在 notify_url 返回一个 success 以告诉支付宝你已收到订单通知 为了避免掉单，支付宝会在用户付款成功时就不断向 notify_url 发起通知，直至网页返回 success。当然，如果 48 小时后通知仍不成功，则视为交易失败。 诶？要是第二步的时候发现订单金额不对怎么办？面对这种情况，你也可以选择给支付宝返回 fail（我没试过）。但一般不这么做——通常可以先令程序记录下有问题的订单，给支付宝返回 success 后再人工处理。 DEMO 定义两个 URL 的路由： Route::get('/alipay/notify', 'OrdersController@notify')-&gt;name('alipay.notify'); Route::get('/alipay/return', 'OrdersController@paymentSuccess')-&gt;name('alipay.return'); /** * 支付宝网站支付实现 * * @param int $id * * @return \\Illuminate\\Http\\Response */ public function pay(Art $art, Order $order) { if ($order-&gt;status == 'unpaid') { // 构建支付信息 $billing_config = [ 'out_trade_no' =&gt; $order-&gt;order_id, 'total_amount' =&gt; 1, 'subject' =&gt; &quot;订单：$order_id&quot;, 'body' =&gt; &quot;这是 XXX 在网站的 XXX 购买订单，生成于 $order_create_at&quot;, 'timeout_express' =&gt; '1c', // 表示订单将在 1 天后自动关闭 'goods_type' =&gt; '0' ]; // 发起支付请求 return \\Pay::driver('alipay')-&gt;gateway('web')-&gt;pay($billing_config); } abort(404); } public function paymentSuccess(Order $order) { if ($order-&gt;status == 'success') { return view('orders.success', compact('order')); } abort(404); } public function notify(Request $request) { if (\\Pay::driver('alipay')-&gt;gateway('web')-&gt;verify($request-&gt;all())) { /* 接收支付宝通知信息，开始处理 */ // 校验订单号 $order = Order::findorFail($request-&gt;out_trade_no); if ($order-&gt;status == 'unpaid') { // 校验金额 if ($request-&gt;total_amount == $order-&gt;price) { $order-&gt;status = 'success'; // 接下来就是支付成功后的逻辑 // 发货、加积分 blablabla } } else { // 手动记录错误订单 $order-&gt;description = '支付状态异常，原因可能是订单金额不符或者订单状态不满足交易成功要求，请直接联系网站管理员处理。'; $order-&gt;status = 'warning'; $order-&gt;save(); } } // 即使发现异常也返回 success echo &quot;success&quot;; } ","link":"https://blog.g4.cx/post/chu-shi-laravel-zhi-fu-bao-zhi-fu-kai-fa"},{"title":"答案？","content":"这是待在科大的最后一天。 我不知道，为何曾经「转系」、「出国留学」、「考研」的想法如此强烈，而如今我却在三天内办妥了离校手续，踏上从未在我脑海内驻留过，甚至嗤之以鼻的复读道路。 2 个月前，我和父母坐上开往西校区的巴士——沿途从繁华至萧条，最终到达破败。资源贫瘠的地段，满目疮痍的教学楼，苦不堪言的宿舍条件……令我诧异的是，我们三人竟都挂着同样的笑脸，为入住宿舍、办理手续忙得上气不接下气。这个下午过得充实而仓促，老爸忙急着夸食堂规模的豪华，老妈对宿舍氛围更浓厚的六人间感到非常满意，我也是。 但三人应该都知道，唯有「回去」这条底线绝不可说出口。 两个月的时光里，我的心情可谓大起大落。起是为能真正体验大学生活而兴奋不已，落则是现实的残酷无法让我产生丝毫兴奋感。突然得知的与高职生拿同一个文凭证书、遥遥无期的新校区建设进程、充当过场角色的升旗仪式、校运会、学院比赛……除了门外写着的是「大学」二字，我着实没有能将眼前的现实和原先的憧憬挂上钩。想要努力转系转专业，却得知成功后仍需再修一年；想要努力杀托出国留学，却放不下国内舒适的环境，父母的贷款压力；想要努力考研，现在谈之没有反馈，为之过早。从高考出分直至我记事的这一天，似乎我所想的每一个升学途径目的都与深造、都与文凭无关——而是单单地想离开这里，或者是令我转移注意力，别再与这物质条件较劲。 这所学校绝对拥有令人永远也吐不完说不尽的魔力，终日情绪的压抑一定会带来与之对应的思考和结果。果然正在某天清晨，回炉重造的想法一直在我心里挥之不去——然后坚信着这是自己深思熟虑后的结果，于是就有了今天这篇牢骚。 恰让人难以置信的是，在东校区办理手续的这两天，我竟对它留恋不已：我看到了宏伟的教学楼和实验楼、满是活力的学长学姐、校园内处处可见的「船魂精神」标语……这才像是一所真正的大学。倘若时间倒流，我能在下决定前提早到达东区：我必定会动摇吧。 可如今，回头无岸。 前阵子和萝莉名说了这件事，他问我： 「你决定回去的理由是什么？」 我说，这所学校不是 211，我和职业高中的同学一起上课。 「那你回去的意义是什么？」 我说，考一个更高的分数，去一个更高的平台，就可以摆脱这所学校了。 谁知他一下把我的思路敲得粉碎： 「然后呢？上大学的意义是什么？」 当你陷入两难的时候，就预想下每一条道路所能带给你的新生活，之后你将自然而然地得到答案。 就连爱情公寓里也有一套方法论：当你陷入两难的时候，就抛一枚硬币。抛硬币最终得到的结果并不重要，而是在落下的那一瞬间——你自然会得到答案。 我表面上做了决定，实际上自己都不知道为什么。 我的答案，是什么？ ","link":"https://blog.g4.cx/post/Gf3GdU6QM"}]}